import { serve } from "bun";
import { STATUS_CODES } from "http";
import { Database } from "bun:sqlite";

const db = new Database("db.sqlite");

type Contestant = {
  id: number;
  name: string;
};

db.run(`
  CREATE TABLE IF NOT EXISTS contestants (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL
  );
`);

type Method = "GET" | "POST" | "PUT" | "DELETE";

type Handler = (
  request: Request,
  params: Record<string, string>
) => Response | Promise<Response>;

type Route =
  | {
      [K in Method]?: Handler;
    } & { path: string };

const routes: Route[] = [
  {
    path: "/contestants",
    GET: () => {
      const contestants: Contestant[] = db
        .query("SELECT * FROM contestants")
        .all();

      return Response.json(contestants);
    },
    POST: async (request) => {
      const { name } = await request.json<Pick<Contestant, "name">>();

      const contestant: Contestant = db
        .query("INSERT INTO contestants (name) VALUES (?) RETURNING *")
        .get(name);

      return Response.json(contestant, { status: 201 });
    },
  },
  {
    path: "/contestants/:id",
    GET: (request, params) => {
      const { id } = params;

      const contestant = db
        .query("SELECT * FROM contestants WHERE id = ?")
        .get(id);

      return Response.json(contestant);
    },
    DELETE: (_, params) => {
      const { id } = params;

      db.run("DELETE FROM contestants WHERE id = ?", id);
      return new Response();
    },
  },
];

/**
 * comparePath compares requesy path with route template path.
 * @param path request path
 * @param template route tempalte path
 * @returns boolean meaning if it is coorrect or not
 */
// TODO: This says that / is the same as /contestants
const comparePath = (path: string, template: string): boolean => {
  const pathElements = path.split("/");
  const templateElements = path.split("/");

  if (pathElements.length !== templateElements.length) return false;

  for (let i = 0; i < templateElements.length; i++) {
    if (
      templateElements.at(i).startsWith(":") === false &&
      templateElements.at(i) !== pathElements.at(i)
    )
      return false;
  }

  return true;
};

/**
 * getPathParams retrieve path params from request url.
 * @param path
 * @param template
 * @returns
 */
const getPathParams = (
  path: string,
  template: string
): Record<string, string> => {
  const pathElements = path.split("/");
  const templateElements = template.split("/");

  return templateElements.reduce((prev, curr, i) => {
    if (curr.startsWith(":")) prev[curr.slice(1)] = pathElements[i];
    return prev;
  }, {});
};

/**
 * resolver finds registered handler for the request path & method and runs it.
 * @param request http request
 * @param routes route definitions
 * @returns response generated by route handler or 404 if it does not exist.
 */
const resolver = (request: Request, routes: Route[]): Response => {
  const { pathname } = new URL(request.url);

  const route = routes.find((route) => comparePath(pathname, route.path));
  const handler = route?.[request.method];
  if (!handler) return new Response(STATUS_CODES[404], { status: 404 });

  const params = getPathParams(pathname, route.path);
  return handler(request, params);
};

serve({
  fetch: (request) => {
    return resolver(request, routes);
  },
  error: (error: Error) => {
    return new Response(`Error! ${error.toString()}`, {
      status: 500,
    });
  },
});

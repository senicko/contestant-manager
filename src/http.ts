import { STATUS_CODES } from "http";
import { record, TypeOf, ZodError } from "zod";

/**
 * logs incoming requests to the console.
 * @param request incoming request
 */
export const log = (request: Request, response: Response) =>
  console.log(
    `${request.method} ${request.url} -> ${response.status} ${
      STATUS_CODES[response.status]
    }`
  );

export type Handler = (
  request: Request,
  params: Record<string, string>
) => Promise<Response>;

export type Route =
  | {
      [K in Method]?: Handler;
    } & { path: string };

/**
 * comparePath compares requesy path with route template path.
 * @param path request path
 * @param template route tempalte path
 * @returns boolean meaning if it is coorrect or not
 */
// TODO: This says that / is the same as /contestants
const comparePath = (path: string, template: string) => {
  const pathElements = path.split("/");
  const templateElements = template.split("/");

  if (pathElements.length !== templateElements.length) return false;

  for (let i = 0; i < templateElements.length; i++) {
    if (
      !templateElements.at(i)?.startsWith(":") &&
      templateElements.at(i) !== pathElements.at(i)
    )
      return false;
  }

  return true;
};

/**
 * getPathParams retrieve path params from request url.
 * @param path
 * @param template
 * @returns
 */
const getPathParams = (
  path: string,
  template: string
): Record<string, string> => {
  const pathElements = path.split("/");
  const templateElements = template.split("/");

  return templateElements.reduce((prev, curr, i) => {
    if (curr.startsWith(":")) prev[curr.slice(1)] = pathElements[i];
    return prev;
  }, {} as Record<string, string>);
};

export type Method = "GET" | "POST" | "PUT" | "DELETE";

/** Checks if method is one of allow method in a route definition. */
const isAllowedMethod = (method: string): method is Method =>
  ["GET", "POST", "PUT", "DELETE"].includes(method);

/**
 * resolver finds registered handler for the request path & method and runs it.
 * @param request http request
 * @param routes route definitions
 * @returns response generated by route handler or 403 if it does not exist.
 */
export const resolver = async (
  request: Request,
  routes: Route[]
): Promise<Response> => {
  const { pathname } = new URL(request.url);

  const route = routes.find((route) => comparePath(pathname, route.path));
  console.log(route, request.method, isAllowedMethod(request.method));

  if (!(route && isAllowedMethod(request.method) && route[request.method]))
    return new Response(STATUS_CODES[404], { status: 404 });

  // We are sure that there is a handler at this point
  const handler = route[request.method]!;
  const params = getPathParams(pathname, route.path);

  return await handler(request, params);
};

export type CookieOptions = {
  name: string;
  value: string;
  expire?: Date;
  httpOnly?: boolean;
};

/**
 * setCookie adds a cookie to the request.
 * @param headers request headers
 * @param options cookie options
 */
export const setCookie = (headers: Headers, options: CookieOptions): void => {
  let cookie = `${options.name}=${options.value}`;

  if (options.expire) cookie += `; Expires=${options.expire.toUTCString()}`;
  if (options.httpOnly) cookie += "; HttpOnly";

  headers.set("Set-Cookie", `${cookie};`);
};

/**
 * parseCookies parses cookie header and transforms it into a string record.
 * @param request incoming request
 */
export const parseCookies = (request: Request): Record<string, string> => {
  const cookieHeader = request.headers.get("cookie");

  if (!cookieHeader) return {};

  return cookieHeader.split(";").reduce((cookies, cookie) => {
    const [name, value] = cookie.split("=");
    cookies[name] = value;
    return cookies;
  }, {} as Record<string, string>);
};

/**
 * Checks if request is a cors preflight request.
 * @param request incoming request
 * @returns boolean indicating if it is a cors preflight request or not
 */
const isCorsPreflight = (request: Request) => {
  return (
    request.method === "OPTIONS" &&
    request.headers.has("Access-Control-Request-Method") &&
    request.headers.has("Access-Control-Request-Headers") &&
    request.headers.has("Origin")
  );
};

/**
 * Sets CORS headers.
 * @param request incoming request
 * @param response request response
 */
export const cors = async (
  request: Request,
  next: (request: Request) => Promise<Response>
): Promise<Response> => {
  const corsHeaders: HeadersInit = {
    "Access-Control-Allow-Origin": "http://localhost:4200",
    "Access-Control-Allow-Methods": "POST, GET, OPTIONS, DELETE",
    "Access-Control-Allow-Headers": "content-type",
    "Access-Control-Allow-Credentials": "true",
  };

  if (isCorsPreflight(request)) {
    return new Response("", {
      status: 214,
      headers: {
        ...corsHeaders,
        Connection: "keep-alive",
      },
    });
  }

  const response = await next(request);

  Object.entries(corsHeaders).forEach(([header, value]) => {
    response.headers.set(header, value);
  });

  return response;
};

/**
 * Helper that logs an error and creates error response.
 * @param status error response status
 * @param message error message
 * @return erro response
 */
export const error = (status: number, error: string): Response => {
  return Response.json({ status: "error", error }, status);
};
